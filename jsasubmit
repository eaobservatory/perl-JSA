#!/bin/env starperl

=head1 NAME

jsasubmit - Submit a job to the CADC GridEngine for JSA processing.

=head1 SYNOPSIS

  jsasubmit -ut 20080705

=head1 DESCRIPTION

Submits a processing job to the CADC data processing system.

=head1 OPTIONS

=over 4

=item B<-debug>

Enable debug messages and do not actually submit a processing job. Also
disables emailing.

=item B<-help>

Print help information.

=item B<-man>

Print full manual.

=item B<-noemail>

By default a mail message is sent with the job details. If this option is given
the message will be printed to standard output instead.

=item B<-priority>

Used to override the default priority for all jobs. Must be an integer between
-1023 and 1024. The default will be 1.

=item B<-project>

Name of a project to be processed. Should not be used with the "-ut" option. Files
are not verified to be present at CADC in this mode.

=item B<-queue>

Can be used to override the queue that should be used for the data processing
at CADC. Can be left unset. Useful values are "JAC_REPROC" for low priority
reprocessing.

=item B<-ut>

Specify the UT date to be processed. Should not be used with the "-project" option.
Files to be processed are verified to be at CADC before a job will be submitted.

=item B<-version>

Print version information.

=back

=cut


use JAC::Setup qw/ omp oracdr sybase /;

use strict;
use warnings;

use JSA::CADC_Copy;
use JSA::CADC_DP qw/ connect_to_cadcdp disconnect_from_cadcdp
                     create_recipe_instance /;
use JSA::Error qw/ :try /;
use JSA::Files qw/ file_to_uri /;
use JSA::Headers qw/ get_orac_instrument /;

use OMP::ArchiveDB;
use OMP::Info::Obs;
use OMP::Info::ObsGroup;
use ORAC::Inst::Defn qw/ orac_determine_inst_classes /;
use OMP::Constants qw/ :obs /;

use Getopt::Long;
use Net::SMTP;
use Pod::Usage;
use File::Basename;

my $TELESCOPE = 'JCMT';
my $BASEURL = "http://test.cadc-ccda.hia-iha.nrc-cnrc.gc.ca/dp/recipe/";
my $MAILHOST = 'mailhost.jach.hawaii.edu';
my $MAILTO = 'jcmtarch@jach.hawaii.edu';
my $MAILFROM = 'jcmtarch@jach.hawaii.edu';

# Don't fall back to files.
$OMP::ArchiveDB::FallbackToFiles = 0;

# Use DB for any date.
$OMP::ArchiveDB::AnyDate = 1;

# Fix search criteria to avoid being reset just before querying for data.
OMP::ArchiveDB->use_existing_criteria( 1 );

# Handle command-line options.
my ( $help, $man, $mode, $project, $ut, $version, $priority, $noemail, $debug, $queue );
my $status = GetOptions( "help"      => \$help,
                         "man"       => \$man,
                         "project=s" => \$project,
                         "ut=s"      => \$ut,
                         "priority=i"=> \$priority,
                         "version"   => \$version,
                         "debug"     => \$debug,
                         "noemail"   => \$noemail,
                         "queue=s"     => \$queue,
                       );

pod2usage( 1 ) if $help;
pod2usage( -exitstatus => 0, -verbose => 2 ) if $man;

if( $version ) {
  print "Submit a job to the CADC GridEngine for JSA processing.\n";
  print " Source code revision: 0.01\n";
  exit;
}

# Make sure the UT parameter is defined.
if( ! defined $ut && ! defined $project ) {
  die "Must include either -ut or -project parameter";
} elsif (defined $ut && defined $project ) {
  die "Can not include both -ut and -project parameters";
}

my $pristring = 'with default priority';
if (defined $priority) {
  $pristring = "with priority $priority";
}

if( defined( $project ) ) {
  $mode = "project";
  $project = uc( $project );
  log_message( "Running jsasubmit for project $project $pristring.\n");
} else {
  log_message( "Running jsasubmit for UT date $ut $pristring.\n");
  $mode = "night";
}

# SLEDGE HAMMER HACK
#  We need to be able to control pipeline recipe names when doing night
#  processing. Currently the submission script will supply an project
#  based recipe parameter file in project mode but not in night mode. This
#  will not trigger a completely different recipe though. For now we
#  have a local hash rather than an external config file during submission.
#  We provide a recipe override based on the most recent project id added
#  to the group. We only need to override blank field observations for SCUBA-2

my %DR_RECIPES = (
                  M09BI152 => "REDUCE_SCAN_FAINT_POINT_SOURCES",
                  M09BI155 => "REDUCE_SCAN_FAINT_POINT_SOURCES",
                  M09BI143 => "REDUCE_SCAN_FAINT_POINT_SOURCES",
                  M09BI115 => "REDUCE_SCAN_FAINT_POINT_SOURCES",
                  M09BI128 => "REDUCE_SCAN_FAINT_POINT_SOURCES",
                  M09BI136 => "REDUCE_SCAN_FAINT_POINT_SOURCES",
                  M09BI120 => "REDUCE_SCAN_FAINT_POINT_SOURCES",
                  M09BI101 => "REDUCE_SCAN_FAINT_POINT_SOURCES",
                  M09BI109 => "REDUCE_SCAN_FAINT_POINT_SOURCES",
                  M09BI130 => "REDUCE_SCAN_FAINT_POINT_SOURCES",
                  M09BI104 => "REDUCE_SCAN_FAINT_POINT_SOURCES",
                  M09BI149 => "REDUCE_SCAN_FAINT_POINT_SOURCES",
                  M09BI134 => "REDUCE_SCAN_FAINT_POINT_SOURCES",
                  M09BI145 => "REDUCE_SCAN_FAINT_POINT_SOURCES",
                  M09BI114 => "REDUCE_SCAN_FAINT_POINT_SOURCES",
                  M09BI142 => "REDUCE_SCAN_FAINT_POINT_SOURCES",
                  M09BH101A => "REDUCE_SCAN_FAINT_POINT_SOURCES",
                  M09BH102A => "REDUCE_SCAN_FAINT_POINT_SOURCES",
                  M09BH103A => "REDUCE_SCAN_FAINT_POINT_SOURCES",
                  M09BH105A => "REDUCE_SCAN_FAINT_POINT_SOURCES",
                  M09BH106B => "REDUCE_SCAN_FAINT_POINT_SOURCES",
);


my $grp;
my $atCADC;
if( $mode eq 'project' ) {
  $grp = new OMP::Info::ObsGroup( projectid => $project,
                                  nocomments => 0,
                                  retainhdr => 1 );
} else {
  $grp = new OMP::Info::ObsGroup( telescope => $TELESCOPE,
                                  date => $ut,
                                  nocomments => 0,
                                  retainhdr => 1 );
  $atCADC = JSA::CADC_Copy::at_cadc( $ut );
}

if( scalar( @{$grp->obs} ) == 0 ) {
  log_message( "No observations were retrieved from the database.\n");
} else {
  log_message( scalar( @{$grp->obs} ) . " observations were retrieved from the database.\n\n");

  # Hash to hold list of groups and information about them.
  # Keys will be the group association id string
  # Value will be a hash reference containing keys
  #   files => []  array of files for this group
  #   drparams => DR parameters
  #   mode => mode to use for processing
  #   dprecipe => DP recipe to use for this group
  my %groups;

  # Hash to hold list of ORAC::Frame::<inst> classes already loaded.
  my %frameclassloaded;

  foreach my $obs ( $grp->obs ) {

    my $hdr = $obs->hdrhash;

    my $obstype = uc( $hdr->{'OBS_TYPE'} );
    my $instrume = uc( $hdr->{'INSTRUME'} );
    my $backend = uc( $hdr->{'BACKEND'} );

    # We process SCIENCE and POINTING for SCUBA-2, and SCIENCE for
    # ACSIS.
    if( ! ( ( $instrume eq 'SCUBA-2' &&
              ( $obstype eq 'SCIENCE' ||
                $obstype eq 'POINTING' ) ) ||
            ( $backend eq 'ACSIS' && $obstype eq 'SCIENCE' ) ) ) {
      next;
    }

    # Check to see if we have OBSRA and OBSDEC. If they're defined,
    # the tracking system is J2000. Otherwise it's APP.
    if( ! defined( $hdr->{'TRACKSYS'} ) ) {
      if( defined( $hdr->{'OBSRA'} ) &&
          defined( $hdr->{'OBSDEC'} ) ) {
        $hdr->{'TRACKSYS'} = 'J2000';
      } else {
        $hdr->{'TRACKSYS'} = 'APP';
      }
    }

    # OBSRA and OBSDEC are always ICRS so we have to be careful
    # if we switch to GALACTIC. The safest solution is to add
    # BASEC1, BASEC2 and TRACKSYS to the database table since those
    # are the values used by ORAC-DR group assignment (although only
    # for night mode in reality).
    if( defined( $hdr->{'OBSRA'} ) ) {
      $hdr->{'BASEC1'} = $hdr->{'OBSRA'};
    }
    if( defined( $hdr->{'OBSDEC'} ) ) {
      $hdr->{'BASEC2'} = $hdr->{'OBSDEC'};
    }

    if( defined( $hdr->{'FREQ_SIG_LOWER'} ) ) {
      $hdr->{'FRQSIGLO'} = $hdr->{'FREQ_SIG_LOWER'};
    }
    if( defined( $hdr->{'FREQ_SIG_UPPER'} ) ) {
      $hdr->{'FRQSIGHI'} = $hdr->{'FREQ_SIG_UPPER'};
    }

    # The database will not have a SIMULATE header so assume
    # it is false.
    if( ! defined( $hdr->{'SIMULATE'} ) ) {
      $hdr->{'SIMULATE'} = 0;
    }

    my $instrument = get_orac_instrument( $obs->fits );

    my ( $frameclass, $groupclass, $calclass, $instclass ) = orac_determine_inst_classes( $instrument );
    if( ! $frameclassloaded{$frameclass} ) {
      my $isok = eval " require $frameclass; 1; ";
      if( ! $isok ) {
        die "Could not load $frameclass: $@\n";
      }
      $frameclassloaded{$frameclass}++;
    }

    # Current default values for this observation in group handling and
    # recipe submission
    my %current;

    # If the observation is NOT GOOD we don't want to combine it with other
    # members of the group so we just want to submit it standalone.
    # REJECT status could arguably be included in full coadds but for now
    # we only combine GOOD.

    # Observations to be processed standalone need to be reduced in "obs" mode.

    # We do not process bad observations in PROJECT mode since we assume they have
    # already been done in NIGHT mode

    my $not_in_group = "";
    $current{mode} = $mode;
    if ( $obs->status != OMP__OBS_GOOD ) {
      # Do not care about group so add a disambiguater based on obsid
      log_message( "Observation with OBSID ". $obs->obsid ." is not good so will not be included in a group\n" );
      $not_in_group = $obs->obsid;
      $current{mode} = "obs";

      # Skip to next observation unless we are in night mode
      if ($mode ne "night") {
        log_message("Not including this observation in $mode processing\n");
        next;
      }
    }

    # Make an estimate of the resources required to process the observation
    # The rule is something like:
    #  ACSIS
    #     - HARP scan maps: 16G
    #     - Everything else: 8G
    #  SCUBA-2
    #     - Observations longer than about 20 minutes: 16G
    #     - Everything else: 8G
    #    When we have multiple subarrays the 20 minutes will scale accordingly.
    #    and we'll need to switch to a 64G queue for those.
    $current{dprecipe} = JSA::CADC_DP::CADC_DPREC_8G;
    if ( $instrume eq 'SCUBA-2' ) {
      my $duration = $obs->endobs - $obs->startobs;
      # We currently have a problem with the database ingestion so we
      # do not really know the duration of the observation. We therefore
      # count the number of files as a surrogate (noting that this count
      # includes all subarrays so we need to divide by two for the
      # wavelength); This is not accurate.
      my @files = $obs->filename;
      my $nfiles = @files / 2;
      if ($nfiles > 35) {
        $current{dprecipe} = JSA::CADC_DP::CADC_DPREC_16G;
      }
    } elsif ( $instrume eq 'HARP' && $hdr->{SAM_MODE} =~ /scan|raster/i) {
      $current{dprecipe} = JSA::CADC_DP::CADC_DPREC_16G;
    }

    if ( exists $DR_RECIPES{$obs->projectid} ) {
      $current{drparams} = $DR_RECIPES{$obs->projectid};
    }

    # with no subheaders sometimes we get an empty hash so we check for that
    if( exists $hdr->{SUBHEADERS} &&
        defined $hdr->{SUBHEADERS} &&
        @{$hdr->{SUBHEADERS}} > 0 &&
        keys %{$hdr->{SUBHEADERS}->[0]} > 0 ) {

      # There are sometimes multiple files per subsystem
      # but they each have a separate subhdr. We need to merge them
      # back to a per-subsystem scheme

      my %commonhdr = %$hdr;
      my %subsystems;
      for my $subhdr ( @{$commonhdr{SUBHEADERS}} ) {
        my $obsidss = get_obsidss( $obs->obsid, $subhdr, \%commonhdr );
        if (exists $subsystems{$obsidss}) {
          push( @{$subsystems{$obsidss}{FILE_ID}}, $subhdr->{FILE_ID});
        } else {
          # initialise the subsystem entry
          $subsystems{$obsidss} = { %$subhdr };
          $subsystems{$obsidss}{FILE_ID} = [ $subhdr->{FILE_ID} ];
        }
      }

      for my $obsidss (sort keys %subsystems) {

        my $subhdr = $subsystems{$obsidss};

        # Merge common with subheader
        my %tmphdr = (%commonhdr, %{$subhdr});

        if( defined( $tmphdr{'FREQ_SIG_LOWER'} ) ) {
          $tmphdr{'FRQSIGLO'} = $tmphdr{'FREQ_SIG_LOWER'};
        }
        if( defined( $tmphdr{'FREQ_SIG_UPPER'} ) ) {
          $tmphdr{'FRQSIGHI'} = $tmphdr{'FREQ_SIG_UPPER'};
        }

        assign_to_group( $instrument, $frameclass, $not_in_group,
                         \%tmphdr, \%current, $tmphdr{FILE_ID}, \%groups );
      }
    } else {
      assign_to_group( $instrument, $frameclass, $not_in_group,
                       $hdr, \%current, [$obs->filename], \%groups );
    }
  }

  my $dbh;
  if ($debug) {
    log_message( "Would be connecting to CADC data processing database here\n" );
  } else {
    log_message( "Connecting to CADC data processing database...");
    $dbh = connect_to_cadcdp;
    log_message( "connected!\n\n");
  }

  foreach my $group ( sort keys %groups ) {
    log_message( "Requesting CADC processing of the following files:\n");
    log_message( map { "$_\n" } @{$groups{$group}{files}});
    my @members = map { file_to_uri( $_ ) } @{$groups{$group}{files}};

    # Only check for night mode. If we're in project mode, assume the
    # files are at CADC.
    if( $mode eq 'night' ) {
      log_message( "Checking to ensure files are at CADC...\n");
      my $there = 1;
      foreach my $file ( @{$groups{$group}{files}} ) {
        $file =~ s/\.sdf$//;
        if( ! exists( $atCADC->{$file} ) ) {
          $there = 0;
          log_message( "$file is not at CADC!\n");
        }
      }
      if( ! $there ) {
        log_message( "One or more files from current group not at CADC.\nSkipping to next group.\n");
        next;
      }
      log_message( "All files are at CADC. Submitting processing request.\n");
    }

    # Submit the job.
    my $recipe_id;
    try {
      my %opts;
      $opts{'mode'} = ( exists $groups{$group}{mode} ? $groups{$group}{mode} : $mode);
      if( $mode eq 'project' ) {
        $opts{'project'} = $project;
      }
      $opts{priority} = $priority if defined $priority;
      $opts{queue} = $queue if defined $queue;
      if ( exists $groups{$group}{drparams} ) {
        $opts{drparams} = $groups{$group}{drparams};
      }

      if (exists $groups{$group}{dprecipe}) {
        $opts{dprecipe} = $groups{$group}{dprecipe};
      }

      if ($debug) {
        log_message( "Would be submitting job with options:\n");
        for my $k (sort keys %opts) {
           log_message( "\t$k : ".(defined $opts{$k} ? $opts{$k} : "<undef>")."\n");
        }
        $recipe_id = "0xFabCADC";
      } else {
        $recipe_id = create_recipe_instance( $dbh, \@members, \%opts );
      }
    }
    catch JSA::Error::CADCDB with {
      my $Error = shift;
      log_message( "Error in CADC DB connectivity: $Error");
      log_message( "Skipping to next group.\n");
    }
    otherwise {
      my $Error = shift;
      $Error->throw;
    };
    if (!defined $recipe_id) {
      log_message( "Error submitting. No recipe id returned\n");
      last;
    } else {
      log_message( "Request submitted with recipe instance $recipe_id.\n");
      log_message( "Recipe URL: $BASEURL" . hex($recipe_id) . "\n");
      log_message( "\n");
    }
  }

  if ($debug) {
    log_message( "Would be disconnecting from CADC data processing database here\n");
  } else {
    log_message( "Disconnecting from CADC data processing database...");
    disconnect_from_cadcdp( $dbh );
    log_message( "disconnected!\n\n");
  }
  log_message( "Data processing requests complete.\n");

}

if ($noemail || $debug) {
  # do not need to send an email message
} else {
  # Send the email.
  my $smtp = Net::SMTP->new( $MAILHOST );
  $smtp->mail( $MAILFROM );
  $smtp->to( $MAILTO );

  $smtp->data();
  $smtp->datasend( "To: $MAILTO\n" );
  $smtp->datasend("Subject: CADC Processing for " . ( defined( $ut ) ? $ut : $project ) . "\n");
  $smtp->datasend("\n");
  $smtp->datasend( all_messages() );

  $smtp->quit;
}

exit;

# Cache for messages, or we just print them straight out
{
  my @MESSAGES;

  sub log_message {
    my @msg = @_;
    if ($debug) {
      print @msg;
    } else {
      push(@MESSAGES, @msg);
    }
  }

  sub all_messages {
    return @MESSAGES;
  }

}

# Quick routine to retrieve OBSIDSS
# Multiple headers can be supplied

sub get_obsidss {
  my $obsid = shift;
  my @hdrs = @_;

  # Try not to merge headers if the answer is in the small one
  my $obsidss;
  for my $k ( qw/ OBSID_SUBSYSNR OBSIDSS SUBSYSNR / ) {
    # try each key in turn
    for my $hdr (@hdrs) {
      if (exists $hdr->{$k}) {
        if ($k eq 'SUBSYSNR') {
          $obsidss = $obsid . "_" . $hdr->{$k};
        } else {
          $obsidss = $hdr->{$k};
        }
        last;
      }
    }
  }
  if (!defined $obsidss) {
    die "Could not work out OBSIDSS for ". $obsid;
  }
  return $obsidss;
}

# Assign the observation to a particular group

sub assign_to_group {
  my $instrument = shift;
  my $frameclass = shift;
  my $not_in_group = shift;
  my $tmphdr = shift;
  my $curref = shift;
  my $fileref = shift;
  my $groups = shift;

  # Deref some hashes and arrays
  my %current = %$curref;

  # Strip any paths
  my @files = map { basename($_) } @$fileref;

  # Set ORAC_INSTRUMENT so SCUBA-2 works.
  my $ORAC_INSTRUMENT = '';
  if( exists $tmphdr->{SUBSYSNR} &&
      defined $tmphdr->{SUBSYSNR}  &&
      $instrument eq 'SCUBA-2' ) {
    $ORAC_INSTRUMENT = 'SCUBA2_' . $tmphdr->{SUBSYSNR};
  }
  $ENV{'ORAC_INSTRUMENT'} = $ORAC_INSTRUMENT;

  my $frm = new $frameclass;
  $frm->hdr( %$tmphdr );
  my $group = $not_in_group . $frm->findgroup;
  push @{$groups->{$group}{files}}, @files;
  $groups->{$group}{mode} = $current{mode};
  $groups->{$group}{drparams} = $current{drparams} if defined $current{drparams};
  # Only set if either we have no previous value for dprecipe or if the
  # previous value is lower than the current value (so this observation
  # needs more resources than a previous group member)
  if (defined $current{dprecipe}) {
    if (!exists $groups->{$group}{dprecipe} ||
        (exists $groups->{$group}{dprecipe} && $groups->{$group}{dprecipe} < $current{dprecipe})) {
      $groups->{$group}{dprecipe} = $current{dprecipe};
    }
  }
  return $group;
}

=head1 AUTHORS

Brad Cavanagh E<lt>b.cavanagh@jach.hawaii.eduE<gt>
Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2009-2010 Science and Technology Facilities Council.
All Rights Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful,but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut
