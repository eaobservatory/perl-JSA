#!/usr/bin/env starperl

=head1 NAME

jsasubmit - Submit a job to the CADC GridEngine for JSA processing.

=head1 SYNOPSIS

  jsasubmit -ut 20080705

=head1 DESCRIPTION

Submits a processing job to the CADC data processing system.

=head1 OPTIONS

=over 4

=item B<-debug>

Enable debug messages and do not actually submit a processing job. Also
disables emailing.

=item B<-help>

Print help information.

=item B<-man>

Print full manual.

=item B<-noemail>

By default a mail message is sent with the job details. If this option is given
the message will be printed to standard output instead.

=item B<-priority>

Used to override the default priority for all jobs. Must be an integer between
-1023 and 1024. The default will be 1.

=item B<-project>

Name of a project to be processed. Should not be used with the "-ut" option. Files
are not verified to be present at CADC in this mode.

=item B<-queue>

Can be used to override the queue that should be used for the data processing
at CADC. Can be left unset. Useful values are "JAC_REPROC" for low priority
reprocessing.

=item B<-ut>

Specify the UT date to be processed. Should not be used with the "-project" option.
Files to be processed are verified to be at CADC before a job will be submitted.

=item B<-version>

Print version information.

=back

=cut


use JAC::Setup qw/ omp oracdr sybase /;

use strict;
use warnings;

use JSA::CADC_Copy;
use JSA::Headers qw/ get_orac_instrument /;
use JSA::Submission qw/%DR_RECIPES %BAD_OBSIDSS %JUNK_OBSIDSS
                       assign_to_group get_obsidss echo_messages
                       log_message obs_is_fts2_or_pol2_RECIPE
                       prepare_archive_db send_log_email submit_jobs
                       write_log_file/;

use OMP::Info::Obs;
use OMP::Info::ObsGroup;
use ORAC::Inst::Defn qw/ orac_determine_inst_classes /;
use OMP::Constants qw/ :obs /;
use OMP::ProjServer;

use Data::Dumper;
use Getopt::Long;
use Pod::Usage;

prepare_archive_db();

# Handle command-line options.
my ( $help, $man, $mode, $project, $ut, $version, $priority, $noemail, $debug, $queue );
my $status = GetOptions( "help"      => \$help,
                         "man"       => \$man,
                         "project=s" => \$project,
                         "ut=s"      => \$ut,
                         "priority=i"=> \$priority,
                         "version"   => \$version,
                         "debug"     => \$debug,
                         "noemail"   => \$noemail,
                         "queue=s"     => \$queue,
                       );

pod2usage( 1 ) if $help;
pod2usage( -exitstatus => 0, -verbose => 2 ) if $man;

if( $version ) {
  print "Submit a job to the CADC GridEngine for JSA processing.\n";
  print " Source code revision: 0.01\n";
  exit;
}

echo_messages($noemail || $debug);

# Make sure the UT parameter is defined.
if( ! defined $ut && ! defined $project ) {
  die "Must include either -ut or -project parameter";
} elsif (defined $ut && defined $project ) {
  die "Can not include both -ut and -project parameters";
}

my $pristring = 'with default priority';
if (defined $priority) {
  $pristring = "with priority $priority";
}

if( defined( $project ) ) {
  $mode = "project";
  $project = uc( $project );
  log_message( "Running jsasubmit for project $project $pristring.\n");
} else {
  log_message( "Running jsasubmit for UT date $ut $pristring.\n");
  $mode = "night";
}

my $grp;
my $atCADC = undef;
if( $mode eq 'project' ) {

  # Verify the project ID
  if (!OMP::ProjServer->verifyProject( $project )) {
    die "Project '$project' does not seem to exist in the database.\n";
  }

  $grp = new OMP::Info::ObsGroup( projectid => $project,
                                  nocomments => 0,
                                  retainhdr => 1 );
} else {
  $grp = new OMP::Info::ObsGroup( telescope => 'JCMT',
                                  date => $ut,
                                  nocomments => 0,
                                  retainhdr => 1 );
  $atCADC = JSA::CADC_Copy::at_cadc( $ut );
}

if( scalar( @{$grp->obs} ) == 0 ) {
  log_message( "No observations were retrieved from the database.\n");
} else {
  log_message( scalar( @{$grp->obs} ) . " observations were retrieved from the database.\n\n");

  # Group information hash for submit_jobs().
  my %groups;

  # Hash to hold list of ORAC::Frame::<inst> classes already loaded.
  my %frameclassloaded;

  foreach my $obs ( $grp->obs ) {

    my $hdr = $obs->hdrhash;

    my $obstype = uc( $hdr->{'OBS_TYPE'} );
    my $instrume = uc( $hdr->{'INSTRUME'} );
    my $backend = uc( $hdr->{'BACKEND'} );

    # No reduction recipe at CADC yet for (FTS|POL)-2.
    if ( obs_is_fts2_or_pol2_RECIPE( $backend, $obs->drrecipe() ) ) {

      log_message( sprintf "Skipped observation with OBSID %s from FTS-2/POL-2 reduction %s\n",
                      $obs->obsid(),
                      'based on recipe value'
                  );
      next;
    }

    # We process SCIENCE and POINTING for SCUBA-2, and SCIENCE for
    # ACSIS and the DAS.
    unless (
                ( $instrume eq 'SCUBA-2' &&
                      ( $obstype eq 'SCIENCE' ||
                        $obstype eq 'POINTING' ) ) ||
                ( $backend eq 'ACSIS' && $obstype eq 'SCIENCE' ) ||
                ( $backend eq 'DAS'   && $obstype eq 'SCIENCE' )
           ) {
      next;
    }

    # Check to see if we have OBSRA and OBSDEC. If they're defined,
    # the tracking system is J2000. Otherwise it's APP.
    if( ! defined( $hdr->{'TRACKSYS'} ) ) {
      if( defined( $hdr->{'OBSRA'} ) &&
          defined( $hdr->{'OBSDEC'} ) ) {
        $hdr->{'TRACKSYS'} = 'J2000';
      } else {
        $hdr->{'TRACKSYS'} = 'APP';
      }
    }

    # OBSRA and OBSDEC are always ICRS so we have to be careful
    # if we switch to GALACTIC. The safest solution is to add
    # BASEC1, BASEC2 and TRACKSYS to the database table since those
    # are the values used by ORAC-DR group assignment (although only
    # for night mode in reality).
    if( defined( $hdr->{'OBSRA'} ) ) {
      $hdr->{'BASEC1'} = $hdr->{'OBSRA'};
    }
    if( defined( $hdr->{'OBSDEC'} ) ) {
      $hdr->{'BASEC2'} = $hdr->{'OBSDEC'};
    }

    if( defined( $hdr->{'FREQ_SIG_LOWER'} ) ) {
      $hdr->{'FRQSIGLO'} = $hdr->{'FREQ_SIG_LOWER'};
    }
    if( defined( $hdr->{'FREQ_SIG_UPPER'} ) ) {
      $hdr->{'FRQSIGHI'} = $hdr->{'FREQ_SIG_UPPER'};
    }

    # The database will not have a SIMULATE header so assume
    # it is false.
    if( ! defined( $hdr->{'SIMULATE'} ) ) {
      $hdr->{'SIMULATE'} = 0;
    }

    my $instrument = get_orac_instrument( $obs->fits );

    my ( $frameclass, $groupclass, $calclass, $instclass ) = orac_determine_inst_classes( $instrument );
    if( ! $frameclassloaded{$frameclass} ) {
      my $isok = eval " require $frameclass; 1; ";
      if( ! $isok ) {
        die "Could not load $frameclass: $@\n";
      }
      $frameclassloaded{$frameclass}++;
    }

    # Current default values for this observation in group handling and
    # recipe submission
    my %current;

    # If the observation is NOT GOOD we don't want to combine it with other
    # members of the group so we just want to submit it standalone.
    # REJECT status could arguably be included in full coadds but for now
    # we only combine GOOD.

    # Observations to be processed standalone need to be reduced in "obs" mode.

    # We do not process bad observations in PROJECT mode since we assume they have
    # already been done in NIGHT mode

    my $not_in_group;
    $current{mode} = $mode;
    if ( $obs->status != OMP__OBS_GOOD ) {
      # Do not care about group so add a disambiguater based on obsid
      log_message( "Observation with OBSID ". $obs->obsid ." is not good so will not be included in a group\n" );
      $not_in_group = 1;
      $current{mode} = "obs";

      # if the data are truly JUNK we do not want to ask CADC to process the data at
      # all since the chances are excellent that the pipeline will fail
      if ( $obs->status == OMP__OBS_JUNK ) {
        log_message("Observation is junk and so will not be processed at all\n");
        next;
      }

      # Skip to next observation unless we are in night mode
      if ($mode ne "night") {
        log_message("Not including this observation in $mode processing\n");
        next;
      }
    }

    # Make an estimate of the resources required to process the observation
    # The rule is something like:
    #  ACSIS
    #     - HARP scan maps: 16G
    #     - Everything else: 8G
    #  SCUBA-2
    #     - Observations longer than about 20 minutes: 16G
    #     - Everything else: 8G
    #    When we have multiple subarrays the 20 minutes will scale accordingly.
    #    and we'll need to switch to a 64G queue for those.
    $current{dprecipe} = JSA::CADC_DP::CADC_DPREC_8G;
    if ( $instrume eq 'SCUBA-2' ) {
      my $duration = $obs->endobs - $obs->startobs;
      # We count the number of files as a surrogate for required
      # computing resources since we know each file is roughly
      # same length. Assume 2 subsytems.
      my @files = $obs->filename;
      my $nfiles = @files / 2;
      # As of 20100929
      # 16 files => 6.2 GB
      # 22 files => 8.8GB
      # 27 files => 10.7GB
      # 62 files => 26.2 GB
      if ($nfiles > 30) {
        $current{dprecipe} = JSA::CADC_DP::CADC_DPREC_64G;
      } elsif ($nfiles > 16) {
        $current{dprecipe} = JSA::CADC_DP::CADC_DPREC_16G;
      }
    } elsif ( $instrume eq 'HARP' && $hdr->{SAM_MODE} =~ /scan|raster/i) {
      $current{dprecipe} = JSA::CADC_DP::CADC_DPREC_16G;
    }

    # Set up recipe parameters and recipe overrides.
    # We only do this for non-calibrator science observations
    if ( $obstype eq 'SCIENCE' && ! $hdr->{STANDARD}) {
      my $pid = $obs->projectid;
      if (defined $pid) {
        # Override the recipe?
        if ( exists $DR_RECIPES{$pid} ) {
          $current{drparams} = $DR_RECIPES{$pid};
        }

        # We use this for all modes since the parameter file is relevant
        # for both night and project processing.
        $current{recpars} = "recpars-$pid.ini";
      }
    }

    my @subsystems = $obs->subsystems;

    for my $subsys (@subsystems) {
      my @all_obsidss = $subsys->obsidss;
      my $obsidss = $all_obsidss[0];

      die "Error determining an OBSIDSS for an observation. Can not proceed\n"
        unless defined $obsidss;

      # local copies
      my $obsidss_not_in_group = $not_in_group;
      my %obsidss_current = %current;

      if (exists $JUNK_OBSIDSS{$obsidss}) {
	log_message( "Subsystem $obsidss will not be processed in any way\n");
	next;
      }

      if (exists $BAD_OBSIDSS{$obsidss}) {
	log_message( "Subsystem $obsidss should not be included in group processing\n" );
	next if $mode ne "night";
	$obsidss_not_in_group = 1;
	$obsidss_current{mode} = "obs";
      }

      my $subsyshdr = $subsys->hdrhash;

      if( defined( $subsyshdr->{'FREQ_SIG_LOWER'} ) ) {
	$subsyshdr->{'FRQSIGLO'} = $subsyshdr->{'FREQ_SIG_LOWER'};
      }
      if( defined( $subsyshdr->{'FREQ_SIG_UPPER'} ) ) {
	$subsyshdr->{'FRQSIGHI'} = $subsyshdr->{'FREQ_SIG_UPPER'};
      }

      assign_to_group( $instrument, $subsys->obsid, $frameclass, $obsidss_not_in_group,
		       $subsyshdr, \%obsidss_current, [$subsys->filename], \%groups );
    }
  }

  submit_jobs(\%groups, $atCADC, $mode, $priority, $queue, $debug);
}

write_log_file('jsasubmit', $ut, $project) unless $debug;

send_log_email('CADC Processing', $ut, $project)
    unless $noemail || $debug;

exit;

=head1 AUTHORS

Brad Cavanagh E<lt>b.cavanagh@jach.hawaii.eduE<gt>
Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2009-2014 Science and Technology Facilities Council.
All Rights Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful,but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.

=cut
