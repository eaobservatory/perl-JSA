#!perl

=head1 NAME

dpRetrieve - Retrieve files in manner consistent with CADC implementation

=head1 SYNOPSIS

  dpRetrieve --id="<instance id>" name_of_filelist

=head1 DESCRIPTION

The CADC processing environment provides a command for retrieving files
from the CADC archive using URIs provided in a text file. The command
written here is a compatibility version to allow the data processing
system to be tested outside of the CADC environment.

The test version of dpRetrieve can work on file URIs, full paths
to local files, or file names relative to the value of the 
ORAC_DATA_IN environment variable. Current working directory is used
if ORAC_DATA_IN is unset or if the file does not exist in that directory.

If the files are present in the current working directory they will be
touched so that the DR wrapper can recognize that the file is to be
processed. If they are present through a soft link in the local
directory the link is removed and recreated for the same reason. If
the file is in a remote directory a soft link is created. If the file or
soft link pre-exists a check is made to ensure that the new file is the
same as the old file.

=head1 ARGUMENTS

=over 4

=item B<--id>

Unique execution ID generated by external user. This is a compatibility
option and is not used.

=item B<-debug>

Write informational messages to standard error. Not supported by CADC.

=item B<--outputdir>

Controls the directory used to write files that have been
retrieved. Files are located using current working directory (if they
are path-less) regardless of the setting of this parameter. Defaults
to current working directory. This argument is not compatible with
CADC and should not be used by the wrapper script.

=item B<filename>

The name of a text file containing either file URIs or path to a file.

=cut

use strict;
use warnings;

use Getopt::Long;
use Pod::Usage;
use File::Spec;
use Carp;
use URI;

use JSA::Files qw/ uri_to_file /;

# Options
my ($help, $man, $version, $id, $debug, $outdir );
my $status = GetOptions("help" => \$help,
                        "man" => \$man,
                        "version" => \$version,
                        "id=s" => \$id,
                        "outdir=s" => \$outdir,
                        "debug" => \$debug,
                       );

pod2usage(1) if $help;
pod2usage(-exitstatus => 0, -verbose => 2) if $man;

if ($version) {
  my $id = '$Id: racover.pl 14421 2007-09-05 02:37:29Z agarwal $ ';
  print "dpRetrieve - compatibility retrieval script for jsawrapdr\n";
  print " Source code revision: $id\n";
  exit;
}

# output directory defaulting
if ($outdir) {
  print STDERR "Overriding output directory with $outdir\n"
    if $debug;
} else {
  $outdir = File::Spec->curdir;
}

# absolute output directory name for error messages
my $absdir = File::Spec->rel2abs($outdir);

# open the file and read all the lines
my $file = shift(@ARGV);
open (my $fh, "<", $file)
    || die "Could not open supplied filename '$file': $!";
my @lines = <$fh>;
close($fh) || die "Could not close file '$file': $!";

for my $line (@lines) {
  my $fullpath = parse_retrieve_line( $line );
  next unless defined $fullpath;
  # see if that path exists
  if (-e $fullpath) {
    # split into a directory and a filename
    my ($vol, $dir, $file) = File::Spec->splitpath( $fullpath );

    # output location
    $file = File::Spec->catdir( $outdir, $file );

    # see if it exists already in the current dir
    if (-e $file) {
      # We first have to decide whether it is the same
      # file or note
      my @statcurr = stat($file);
      my @statnew  = stat($fullpath);

      my $same = 1;
      for my $i (0..$#statcurr) {
        if ($statcurr[$i] != $statnew[$i]) {
          $same = 0;
          last;
        }
      }
      if (!$same) {
        die "Unable to retrieve file '$fullpath' because a file named '$file' already exists in the retrieve directory ($absdir) and it is different";
      }

      # we know they are the same file
      if (-l $file) {
        # remove the link and remake it
        if (unlink $file) {
          symlink $fullpath, $file
            || die "Could not make soft link to '$file' in retrieve directory ($absdir)\n";
          print STDERR "Re-making soft link for '$file'\n"
            if $debug;
        }
      } else {
        # it is a real file locally and it is the same so we touch
        # it to allow the wrapper script to know that it is required
        my $atime = time;
        my $mtime = $atime;
        utime($atime, $mtime, $file)
          or die "Error touching file '$file' in current directory ($absdir)";
        print STDERR "Touching pre-existing file '$file'\n"
          if $debug;
      }
    } else {
      # make a soft link
      symlink $fullpath, $file
        || print STDERR "Could not make soft link to '$file' in current directory ($absdir)\n";
      print STDERR "Making new soft link for file '$file'\n";
    }
        
  } else {
    print STDERR "File '$fullpath' does not seem to exist\n";
  }
}

exit 0;

# Converts a line retrieved from an "inputs" file into a full path
# Recognizes file:// URLs
# Recognizes ad:JCMT/ URIs
# Recognizes fulle path to file /xxx/yy
# For path-less strings prepends $ORAC_DATA_IN
#   or current dir if not set
# Comments (# xxx) are removed

sub parse_retrieve_line {
  my $line = shift;
  chomp($line);
  $line =~ s/\#.*//;
  return unless $line =~ /\w/;

  my $path;

  # Try it as a URI
  my $uri = URI->new( $line );
  if (!$uri->scheme) {
    $path = $line;
  } elsif ($uri->scheme eq 'ad') {
    $path = uri_to_file( $line );
  } elsif ($uri->scheme eq 'file') {
    $path = $uri->path;
  } else {
    croak "Unsupported URI scheme '".$uri->scheme."'";
  }
  
  # see if we need to attach a directory. We do this if the
  # file is relative.
  if (!File::Spec->file_name_is_absolute) {
    # no directory so we guess ORAC_DATA_IN, else it will have
    # to be current working directory. We check in ORAC_DATA_IN
    if (exists $ENV{ORAC_DATA_IN} &&
        defined $ENV{ORAC_DATA_IN} &&
        -d $ENV{ORAC_DATA_IN}) {
      my $newpath = File::Spec->catdir( $ENV{ORAC_DATA_IN}, $path );
      $path = $newpath if -e $newpath;
    }
  }
  return $path;
}


=head1 AUTHORS

Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>,

=head1 COPYRIGHT

Copyright (C) 2008 Science and Technology Facilities Council.
All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful,but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place,Suite 330, Boston, MA  02111-1307, USA

=cut
